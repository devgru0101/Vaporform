# DevOps & Deployment Pipeline

## CI/CD Architecture

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                           DevOps Pipeline Architecture                         │
│                                                                                 │
│  ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐            │
│  │   Source Code   │───▶│  CI Pipeline    │───▶│  CD Pipeline    │            │
│  │   (GitHub)      │    │  (GitHub        │    │  (Docker +      │            │
│  │                 │    │   Actions)      │    │   Kubernetes)   │            │
│  └─────────────────┘    └─────────────────┘    └─────────────────┘            │
│                                 │                       │                      │
│  ┌─────────────────────────────────────────┐    ┌─────────────────┐            │
│  │           Testing Pipeline              │    │   Monitoring    │            │
│  │  [Unit] [Integration] [E2E] [Security] │    │   & Alerting    │            │
│  └─────────────────────────────────────────┘    └─────────────────┘            │
│                                 │                       │                      │
│  ┌─────────────────────────────────────────────────────────────────────────────┐ │
│  │                        Deployment Environments                             │ │
│  │  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐            │ │
│  │  │  Development    │  │     Staging     │  │   Production    │            │ │
│  │  │  Environment    │  │   Environment   │  │   Environment   │            │ │
│  │  └─────────────────┘  └─────────────────┘  └─────────────────┘            │ │
│  └─────────────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────────┘
```

## GitHub Actions CI/CD Pipeline

### 1. Main CI Pipeline

```yaml
# .github/workflows/ci.yml
name: Vaporform CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: vaporform

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: vaporform_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      
      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linting
        run: npm run lint

      - name: Run type checking
        run: npm run type-check

      - name: Run unit tests
        run: npm run test:unit
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/vaporform_test
          REDIS_URL: redis://localhost:6379

      - name: Run integration tests
        run: npm run test:integration
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/vaporform_test
          REDIS_URL: redis://localhost:6379

      - name: Generate test coverage
        run: npm run test:coverage

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          token: ${{ secrets.CODECOV_TOKEN }}

  security-scan:
    name: Security Scanning
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Run npm audit
        run: npm audit --audit-level moderate

      - name: Run Snyk security scan
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

  build:
    name: Build and Push Images
    runs-on: ubuntu-latest
    needs: [test, security-scan]
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./docker/Dockerfile.backend
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push frontend image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./docker/Dockerfile.frontend
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main'
    environment: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure kubectl
        uses: azure/k8s-set-context@v3
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.KUBE_CONFIG_STAGING }}

      - name: Deploy to staging
        run: |
          envsubst < k8s/staging/deployment.yaml | kubectl apply -f -
          kubectl rollout status deployment/vaporform-backend -n vaporform-staging
          kubectl rollout status deployment/vaporform-frontend -n vaporform-staging
        env:
          IMAGE_TAG: ${{ github.sha }}

      - name: Run smoke tests
        run: npm run test:smoke
        env:
          STAGING_URL: https://staging.vaporform.com

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: deploy-staging
    if: github.ref == 'refs/heads/main'
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure kubectl
        uses: azure/k8s-set-context@v3
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.KUBE_CONFIG_PRODUCTION }}

      - name: Deploy to production
        run: |
          envsubst < k8s/production/deployment.yaml | kubectl apply -f -
          kubectl rollout status deployment/vaporform-backend -n vaporform-production
          kubectl rollout status deployment/vaporform-frontend -n vaporform-production
        env:
          IMAGE_TAG: ${{ github.sha }}

      - name: Run production smoke tests
        run: npm run test:smoke
        env:
          PRODUCTION_URL: https://vaporform.com

      - name: Notify deployment success
        uses: 8398a7/action-slack@v3
        with:
          status: success
          text: 'Vaporform successfully deployed to production! 🚀'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
```

### 2. Docker Configuration

```dockerfile
# docker/Dockerfile.backend
FROM node:20-alpine AS builder

WORKDIR /app

# Copy package files
COPY package*.json ./
COPY backend/package*.json ./backend/

# Install dependencies
RUN npm ci --only=production && npm cache clean --force

# Copy source code
COPY backend/ ./backend/
COPY shared/ ./shared/

# Build the application
RUN npm run build

# Production stage
FROM node:20-alpine AS production

# Install security updates
RUN apk update && apk upgrade && apk add --no-cache dumb-init

# Create non-root user
RUN addgroup -g 1001 -S vaporform && \
    adduser -S vaporform -u 1001

WORKDIR /app

# Copy built application
COPY --from=builder --chown=vaporform:vaporform /app/dist ./dist
COPY --from=builder --chown=vaporform:vaporform /app/node_modules ./node_modules
COPY --from=builder --chown=vaporform:vaporform /app/package.json ./

# Switch to non-root user
USER vaporform

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node dist/health-check.js

# Expose port
EXPOSE 4000

# Use dumb-init for proper signal handling
ENTRYPOINT ["dumb-init", "--"]
CMD ["node", "dist/main.js"]
```

```dockerfile
# docker/Dockerfile.frontend
FROM node:20-alpine AS builder

WORKDIR /app

# Copy package files
COPY package*.json ./
COPY frontend/package*.json ./frontend/

# Install dependencies
RUN npm ci && npm cache clean --force

# Copy source code
COPY frontend/ ./frontend/
COPY shared/ ./shared/

# Build the application
ENV NODE_ENV=production
RUN npm run build

# Production stage with nginx
FROM nginx:alpine AS production

# Install security updates
RUN apk update && apk upgrade

# Copy built files
COPY --from=builder /app/dist /usr/share/nginx/html

# Copy nginx configuration
COPY docker/nginx.conf /etc/nginx/nginx.conf
COPY docker/default.conf /etc/nginx/conf.d/default.conf

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:80/health || exit 1

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
```

### 3. Kubernetes Deployment Configuration

```yaml
# k8s/production/namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: vaporform-production
  labels:
    name: vaporform-production
    environment: production

---
# k8s/production/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: vaporform-config
  namespace: vaporform-production
data:
  NODE_ENV: "production"
  LOG_LEVEL: "info"
  CORS_ORIGIN: "https://vaporform.com"
  API_RATE_LIMIT: "1000"
  CONTAINER_TIMEOUT: "300"

---
# k8s/production/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: vaporform-secrets
  namespace: vaporform-production
type: Opaque
data:
  DATABASE_URL: <base64-encoded-database-url>
  JWT_SECRET: <base64-encoded-jwt-secret>
  CLAUDE_API_KEY: <base64-encoded-claude-key>
  REDIS_URL: <base64-encoded-redis-url>

---
# k8s/production/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: vaporform-backend
  namespace: vaporform-production
  labels:
    app: vaporform-backend
    version: v1
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  selector:
    matchLabels:
      app: vaporform-backend
  template:
    metadata:
      labels:
        app: vaporform-backend
        version: v1
    spec:
      serviceAccountName: vaporform-backend
      securityContext:
        runAsNonRoot: true
        runAsUser: 1001
        fsGroup: 1001
      containers:
      - name: backend
        image: ghcr.io/vaporform:${IMAGE_TAG}
        imagePullPolicy: Always
        ports:
        - containerPort: 4000
          name: http
        env:
        - name: PORT
          value: "4000"
        envFrom:
        - configMapRef:
            name: vaporform-config
        - secretRef:
            name: vaporform-secrets
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 4000
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /ready
            port: 4000
          initialDelaySeconds: 5
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 3
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop:
            - ALL

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: vaporform-frontend
  namespace: vaporform-production
  labels:
    app: vaporform-frontend
    version: v1
spec:
  replicas: 2
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  selector:
    matchLabels:
      app: vaporform-frontend
  template:
    metadata:
      labels:
        app: vaporform-frontend
        version: v1
    spec:
      containers:
      - name: frontend
        image: ghcr.io/vaporform-frontend:${IMAGE_TAG}
        imagePullPolicy: Always
        ports:
        - containerPort: 80
          name: http
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /health
            port: 80
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 5

---
# k8s/production/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: vaporform-backend-service
  namespace: vaporform-production
  labels:
    app: vaporform-backend
spec:
  selector:
    app: vaporform-backend
  ports:
  - name: http
    port: 80
    targetPort: 4000
    protocol: TCP
  type: ClusterIP

---
apiVersion: v1
kind: Service
metadata:
  name: vaporform-frontend-service
  namespace: vaporform-production
  labels:
    app: vaporform-frontend
spec:
  selector:
    app: vaporform-frontend
  ports:
  - name: http
    port: 80
    targetPort: 80
    protocol: TCP
  type: ClusterIP

---
# k8s/production/ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: vaporform-ingress
  namespace: vaporform-production
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    nginx.ingress.kubernetes.io/rate-limit: "100"
    nginx.ingress.kubernetes.io/rate-limit-window: "1m"
spec:
  tls:
  - hosts:
    - vaporform.com
    - api.vaporform.com
    secretName: vaporform-tls
  rules:
  - host: vaporform.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: vaporform-frontend-service
            port:
              number: 80
  - host: api.vaporform.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: vaporform-backend-service
            port:
              number: 80
```

## Infrastructure as Code (Terraform)

### 1. Main Infrastructure

```hcl
# terraform/main.tf
terraform {
  required_version = ">= 1.0"
  required_providers {
    kubernetes = {
      source  = "hashicorp/kubernetes"
      version = "~> 2.23"
    }
    helm = {
      source  = "hashicorp/helm"
      version = "~> 2.11"
    }
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
  
  backend "s3" {
    bucket = "vaporform-terraform-state"
    key    = "production/terraform.tfstate"
    region = "us-west-2"
  }
}

provider "aws" {
  region = var.aws_region
}

# EKS Cluster
module "eks" {
  source = "./modules/eks"
  
  cluster_name    = "vaporform-production"
  cluster_version = "1.28"
  
  vpc_id     = module.vpc.vpc_id
  subnet_ids = module.vpc.private_subnets
  
  node_groups = {
    main = {
      desired_capacity = 3
      max_capacity     = 10
      min_capacity     = 2
      
      instance_types = ["t3.large"]
      capacity_type  = "ON_DEMAND"
      
      k8s_labels = {
        Environment = "production"
        Application = "vaporform"
      }
    }
    
    spot = {
      desired_capacity = 2
      max_capacity     = 5
      min_capacity     = 0
      
      instance_types = ["t3.medium", "t3.large"]
      capacity_type  = "SPOT"
      
      k8s_labels = {
        Environment = "production"
        Application = "vaporform"
        NodeType    = "spot"
      }
      
      taints = [{
        key    = "spot"
        value  = "true"
        effect = "NO_SCHEDULE"
      }]
    }
  }
}

# RDS PostgreSQL
module "rds" {
  source = "./modules/rds"
  
  identifier = "vaporform-production"
  
  engine         = "postgres"
  engine_version = "15.4"
  instance_class = "db.r6g.large"
  
  allocated_storage     = 100
  max_allocated_storage = 1000
  storage_encrypted     = true
  
  db_name  = "vaporform"
  username = "vaporform"
  password = var.db_password
  
  vpc_security_group_ids = [module.security_groups.rds_sg_id]
  db_subnet_group_name   = module.vpc.database_subnet_group_name
  
  backup_retention_period = 7
  backup_window          = "03:00-04:00"
  maintenance_window     = "sun:04:00-sun:05:00"
  
  deletion_protection = true
  skip_final_snapshot = false
  
  performance_insights_enabled = true
  monitoring_interval         = 60
  
  tags = {
    Environment = "production"
    Application = "vaporform"
  }
}

# ElastiCache Redis
module "redis" {
  source = "./modules/redis"
  
  cluster_id = "vaporform-production"
  
  node_type               = "cache.r6g.large"
  num_cache_nodes         = 1
  parameter_group_name    = "default.redis7"
  port                    = 6379
  
  subnet_group_name   = module.vpc.elasticache_subnet_group_name
  security_group_ids  = [module.security_groups.redis_sg_id]
  
  at_rest_encryption_enabled = true
  transit_encryption_enabled = true
  
  snapshot_retention_limit = 5
  snapshot_window         = "03:00-05:00"
  
  tags = {
    Environment = "production"
    Application = "vaporform"
  }
}
```

### 2. Monitoring and Observability

```hcl
# terraform/modules/monitoring/main.tf
resource "helm_release" "prometheus" {
  name       = "prometheus"
  repository = "https://prometheus-community.github.io/helm-charts"
  chart      = "kube-prometheus-stack"
  namespace  = "monitoring"
  
  create_namespace = true
  
  values = [
    file("${path.module}/values/prometheus.yaml")
  ]
  
  set {
    name  = "grafana.adminPassword"
    value = var.grafana_admin_password
  }
}

resource "helm_release" "loki" {
  name       = "loki"
  repository = "https://grafana.github.io/helm-charts"
  chart      = "loki-stack"
  namespace  = "monitoring"
  
  depends_on = [helm_release.prometheus]
  
  values = [
    file("${path.module}/values/loki.yaml")
  ]
}

resource "helm_release" "jaeger" {
  name       = "jaeger"
  repository = "https://jaegertracing.github.io/helm-charts"
  chart      = "jaeger"
  namespace  = "monitoring"
  
  depends_on = [helm_release.prometheus]
  
  values = [
    file("${path.module}/values/jaeger.yaml")
  ]
}
```

## Automated Deployment Scripts

### 1. Deployment Orchestrator

```typescript
// scripts/deploy.ts
import { DeploymentOrchestrator } from './deployment/DeploymentOrchestrator';
import { EnvironmentManager } from './deployment/EnvironmentManager';
import { HealthChecker } from './deployment/HealthChecker';

export class VaporformDeployment {
  private orchestrator: DeploymentOrchestrator;
  private environmentManager: EnvironmentManager;
  private healthChecker: HealthChecker;
  
  constructor() {
    this.orchestrator = new DeploymentOrchestrator();
    this.environmentManager = new EnvironmentManager();
    this.healthChecker = new HealthChecker();
  }

  async deploy(environment: 'staging' | 'production', imageTag: string): Promise<DeploymentResult> {
    console.log(`Starting deployment to ${environment} with image tag ${imageTag}`);
    
    try {
      // Pre-deployment checks
      await this.preDeploymentChecks(environment);
      
      // Update environment configuration
      await this.environmentManager.updateConfiguration(environment, { imageTag });
      
      // Deploy backend services
      const backendResult = await this.orchestrator.deployBackend(environment, imageTag);
      if (!backendResult.success) {
        throw new Error(`Backend deployment failed: ${backendResult.error}`);
      }
      
      // Deploy frontend
      const frontendResult = await this.orchestrator.deployFrontend(environment, imageTag);
      if (!frontendResult.success) {
        throw new Error(`Frontend deployment failed: ${frontendResult.error}`);
      }
      
      // Wait for rollout to complete
      await this.waitForRollout(environment);
      
      // Health checks
      const healthCheck = await this.healthChecker.performHealthChecks(environment);
      if (!healthCheck.healthy) {
        await this.rollback(environment);
        throw new Error(`Health checks failed: ${healthCheck.errors.join(', ')}`);
      }
      
      // Smoke tests
      await this.runSmokeTests(environment);
      
      console.log(`Deployment to ${environment} completed successfully`);
      
      return {
        success: true,
        environment,
        imageTag,
        deploymentTime: new Date(),
        healthStatus: healthCheck
      };
      
    } catch (error) {
      console.error(`Deployment to ${environment} failed:`, error);
      await this.handleDeploymentFailure(environment, error);
      throw error;
    }
  }

  private async preDeploymentChecks(environment: string): Promise<void> {
    // Check cluster health
    const clusterHealth = await this.healthChecker.checkClusterHealth(environment);
    if (!clusterHealth.healthy) {
      throw new Error(`Cluster health check failed: ${clusterHealth.issues.join(', ')}`);
    }
    
    // Check resource availability
    const resources = await this.environmentManager.checkResourceAvailability(environment);
    if (!resources.sufficient) {
      throw new Error(`Insufficient resources: ${resources.issues.join(', ')}`);
    }
    
    // Verify secrets are present
    await this.environmentManager.verifySecrets(environment);
  }

  private async waitForRollout(environment: string): Promise<void> {
    const timeout = 10 * 60 * 1000; // 10 minutes
    const interval = 10 * 1000; // 10 seconds
    const startTime = Date.now();
    
    while (Date.now() - startTime < timeout) {
      const status = await this.orchestrator.getRolloutStatus(environment);
      
      if (status.completed) {
        return;
      }
      
      if (status.failed) {
        throw new Error(`Rollout failed: ${status.error}`);
      }
      
      console.log(`Rollout in progress: ${status.progress}%`);
      await new Promise(resolve => setTimeout(resolve, interval));
    }
    
    throw new Error('Rollout timeout exceeded');
  }

  private async rollback(environment: string): Promise<void> {
    console.log(`Initiating rollback for ${environment}`);
    
    try {
      await this.orchestrator.rollback(environment);
      console.log(`Rollback completed for ${environment}`);
    } catch (error) {
      console.error(`Rollback failed for ${environment}:`, error);
      throw error;
    }
  }
}
```

This comprehensive DevOps pipeline ensures reliable, secure, and automated deployment of Vaporform across all environments with proper monitoring, health checks, and rollback capabilities.